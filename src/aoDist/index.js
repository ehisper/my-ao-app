"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getComputationPrice = exports.submitTaskAndGetResult = exports.getResult = exports.submitTask = exports.generateKey = exports.listData = exports.uploadData = void 0;
const tslib_1 = require("tslib");
const aoconnect_1 = require("@permaweb/aoconnect");
const arweave_1 = tslib_1.__importDefault(require("arweave"));
const algorithm_1 = require("./algorithm");
const config_1 = require("./config");
const padoarweave_1 = require("./padoarweave");
const dataregistry_1 = require("./processes/dataregistry");
const noderegistry_1 = require("./processes/noderegistry");
const tasks_1 = require("./processes/tasks");
const utils_1 = require("./processes/utils");
/**
 * Encrypt data and upload encrypted data to AR.
 *
 * @param data - plain data need to encrypt and upload
 * @param dataTag - the data meta info
 * @param priceInfo - The data price symbol and price, now only supports AO’s test token AOCRED
 * @param wallet - The ar wallet json object
 * @param arweave - Arweave object generated by arweave-js init method and default is AR production
 * @returns The uploaded encrypted data id
 */
const uploadData = async (data, dataTag, priceInfo, wallet, arweave = arweave_1.default.init({})) => {
    if (data.length === 0) {
        throw new Error('The Data to be uploaded can not be empty');
    }
    // TODO: only support 2-3 at present
    let policy = {
        t: algorithm_1.THRESHOLD_2_3.t,
        n: algorithm_1.THRESHOLD_2_3.n,
        indices: [],
        names: []
    };
    let nodeInfos = await _getNodeInfos(policy.n, true);
    let nodesPublicKey = [];
    for (let i = 0; i < nodeInfos.length; i++) {
        policy.indices.push(nodeInfos[i].index);
        policy.names.push(nodeInfos[i].name);
        nodesPublicKey.push(nodeInfos[i].pk);
    }
    const res = (0, algorithm_1.encrypt)(nodesPublicKey, data, policy);
    const transactionId = await (0, padoarweave_1.submitDataToAR)(arweave, res.enc_msg, wallet);
    const signer = (0, aoconnect_1.createDataItemSigner)(wallet);
    let exData = {
        policy: policy,
        nonce: res.nonce,
        transactionId: transactionId,
        encSks: res.enc_sks
    };
    priceInfo.symbol = priceInfo.symbol || 'AOCRED';
    const dataRes = await (0, dataregistry_1.register)(JSON.stringify(dataTag), JSON.stringify(priceInfo), JSON.stringify(exData), signer);
    return dataRes;
};
exports.uploadData = uploadData;
const listData = async () => {
    const resStr = await (0, dataregistry_1.allData)();
    const res = JSON.parse(resStr);
    return res;
};
exports.listData = listData;
/**
 * Generate key pair for encrypt/decrypt
 *
 * @returns The key-pair object
 */
const generateKey = () => {
    return new Promise((resolve) => {
        setTimeout(() => {
            resolve((0, algorithm_1.keygen)());
        }, 1000);
    });
};
exports.generateKey = generateKey;
/**
 * Submit a task to PADO Network
 *
 * @param dataId - The data id
 * @param dataUserPk - The user's public key generated by keygen
 * @param wallet - The ar wallet json object
 * @returns The submited task id
 */
const submitTask = async (dataId, dataUserPk, wallet) => {
    let encData = await (0, dataregistry_1.getDataById)(dataId);
    encData = JSON.parse(encData);
    const exData = JSON.parse(encData.data);
    const nodeNames = exData.policy.names;
    const priceObj = JSON.parse(encData.price);
    const symbol = priceObj.symbol;
    if (symbol !== 'AOCRED') {
        throw new Error('Only support AOCRED now');
    }
    const dataPrice = priceObj.price;
    //get node price
    const nodePrice = await (0, tasks_1.getComputationPrice)();
    const totalPrice = Number(dataPrice) + Number(nodePrice) * nodeNames.length;
    const signer = (0, aoconnect_1.createDataItemSigner)(wallet);
    try {
        await (0, utils_1.transferAOCREDToTask)(totalPrice.toString(), signer);
    }
    catch (err) {
        if (err === 'Insufficient Balance!') {
            throw new Error('Insufficient Balance! Please ensure that your wallet balance is greater than ' + totalPrice + ' AOCRED');
        }
        else {
            throw err;
        }
    }
    let inputData = { dataId: dataId, consumerPk: dataUserPk };
    const taskId = await (0, tasks_1.submit)(config_1.TASKTYPE, dataId, JSON.stringify(inputData), config_1.COMPUTELIMIT, config_1.MEMORYLIMIT, nodeNames, signer);
    return taskId;
};
exports.submitTask = submitTask;
/**
 * Get the result of the task
 *
 * @param taskId The task id
 * @param dataUserSk - The user's secret key generated by keygen
 * @param arweave - Arweave object generated by arweave-js init method and default is AR production
 * @param timeout Timeout in milliseconds (default: 10 seconds)
 * @returns The data
 */
const getResult = async (taskId, dataUserSk, arweave = arweave_1.default.init({}), timeout = 10000) => {
    const taskStr = await _getCompletedTaskPromise(taskId, timeout);
    const task = JSON.parse(taskStr);
    if (task.verificationError) {
        throw task.verificationError;
    }
    let dataId = JSON.parse(task.inputData).dataId;
    let encData = await (0, dataregistry_1.getDataById)(dataId);
    encData = JSON.parse(encData);
    let exData = JSON.parse(encData.data);
    // TODO: since only support THRESHOLD_2_3 at present, we choice the first t nodes
    let chosenIndices = [];
    let reencChosenSks = [];
    for (let i = 0; i < algorithm_1.THRESHOLD_2_3.t; i++) {
        let index = exData.policy.indices[i];
        chosenIndices.push(index);
        let name = exData.policy.names[i];
        const reencSksObj = JSON.parse(task.result[name]);
        reencChosenSks.push(reencSksObj.reenc_sk);
    }
    const encMsg = await (0, padoarweave_1.getDataFromAR)(arweave, exData.transactionId);
    const res = (0, algorithm_1.decrypt)(reencChosenSks, dataUserSk, exData.nonce, encMsg, chosenIndices);
    return new Uint8Array(res.msg);
};
exports.getResult = getResult;
/**
 * Submit a task to AO and get the result. The combination of submitTask and getResult
 *
 * @param dataId - The data id
 * @param pk - The user's public key generated by keygen
 * @param sk - The user's secret key generated by keygen
 * @param wallet - The ar wallet
 * @param arweave - The ar object and default is ar production
 * @param timeout Timeout in milliseconds (default: 10 seconds)
 * @returns The data
 */
const submitTaskAndGetResult = async (dataId, dataUserPk, dataUserSk, wallet, arweave = arweave_1.default.init({}), timeout = 10000) => {
    const taskId = await (0, exports.submitTask)(dataId, dataUserPk, wallet);
    const result = await (0, exports.getResult)(taskId, dataUserSk, arweave, timeout);
    return result;
};
exports.submitTaskAndGetResult = submitTaskAndGetResult;
/**
 * Get the computing price of each node for each task. Now only supports AO’s test token AOCRED, minimum unit to use AOCRED(1 means 0.001 AOCRED)
 *
 * @returns The computing price of a node
 */
const getComputationPrice = async () => {
    const res = await (0, tasks_1.getComputationPrice)();
    return res;
};
exports.getComputationPrice = getComputationPrice;
/**
 * Get node infos
 *
 * @param n - How many nodes to select
 * @param random - Whether randomly selected
 * @returns The node infos
 */
const _getNodeInfos = async (n, random = false) => {
    let nodesres = await (0, noderegistry_1.nodes)();
    nodesres = JSON.parse(nodesres);
    if (nodesres.length < n) {
        throw `Insufficient number of nodes, expect ${n}, actual ${nodesres.length}`;
    }
    let selected_indices = Array.from({ length: nodesres.length }, (_, i) => i);
    if (random) {
        selected_indices.sort(function () {
            return 0.5 - Math.random();
        });
    }
    let nodeInfos = [];
    for (let i = 0; i < n; i++) {
        let node = nodesres[selected_indices[i]];
        nodeInfos.push({
            org_index: parseInt(node.index),
            index: parseInt(node.index),
            name: node.name,
            pk: node.publickey
        });
    }
    // it's ok, no matter sorted or not
    // nodeInfos.sort((a, b) => a.org_index - b.org_index);
    // re-index, do not care original index
    for (var i = 0; i < nodeInfos.length; i++) {
        nodeInfos[i].index = i + 1;
    }
    return nodeInfos;
};
const _getCompletedTaskPromise = (taskId, timeout) => {
    return new Promise((resolve, reject) => {
        const start = performance.now();
        const tick = async () => {
            const timeGap = performance.now() - start;
            const taskStr = await (0, tasks_1.getCompletedTasksById)(taskId);
            const task = JSON.parse(taskStr);
            if (task.id) {
                resolve(taskStr);
            }
            else if (timeGap > timeout) {
                reject('timeout');
            }
            else {
                setTimeout(tick, 500);
            }
        };
        tick();
    });
};
//# sourceMappingURL=index.js.map